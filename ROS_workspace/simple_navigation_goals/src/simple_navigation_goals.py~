#!/usr/bin/env python

#IMPORTS
import roslib; roslib.load_manifest('simple_navigation_goals')

#--packages
import rospy
import tf
import math
import actionlib  #CLIENT API: http://www.ros.org/doc/api/actionlib/html/classactionlib_1_1simple__action__client_1_1SimpleActionClient.html#a186f5d08f708c020b5f321bec998caff

#--messages
from move_base_msgs.msg import MoveBaseAction
from move_base_msgs.msg import MoveBaseGoal
from geometry_msgs.msg import Quaternion

#INIT NODE & ACTIONLIB
rospy.init_node('move_base_client_py')
client = actionlib.SimpleActionClient('move_base', MoveBaseAction)

client.wait_for_server() #Waits until the action server has started up and started listening for goals.

rospy.loginfo("Done waiting for move_base action server")

#--Creates a goal to send to the action server.
goal = MoveBaseGoal()
goal.target_pose.header.frame_id = "base_link"
goal.target_pose.header.stamp = rospy.get_rostime()

#PERFORM FIRST LOCALIZATION
#--Perform rotation 
goal.target_pose.pose.position.x = 0.0
goal.target_pose.pose.position.y = 0.0 
rotationAngle = math.pi
quat = tf.transformations.quaternion_from_euler(0, 0, rotationAngle)
goal.target_pose.pose.orientation = Quaternion(*quat)

client.send_goal(goal)  # Sends the goal to the action server.
client.wait_for_result() # Waits for the server to finish performing the action.

#--TODO Add feedback stuff 

#--



